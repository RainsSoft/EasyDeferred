//Copyright © 2014 Sony Computer Entertainment America LLC. See License.txt.

namespace RSG
{
    using System;
    using System.ComponentModel;
    //using System.ComponentModel.Composition;
    using System.Threading;
    //using System.Windows.Threading;
    //    /// <summary>
    //    /// Wrapper class that implements ISynchronizeInvoke for WPF applications.</summary>
    //    /// <remarks>
    //    /// The ISynchronizeInvoke and DispatcherAsyncResultAdapter implementations were provided by Rob Paveza, from this post:
    //    /// http://geekswithblogs.net/robp/archive/2008/03/28/why-doesnt-dispatcher-implement-isynchronizeinvoke.aspx </remarks>
    //    [Export(typeof(IInitializable))]
    //    [Export(typeof(ISynchronizeInvoke))]
    //    public class SynchronizeInvoke : ISynchronizeInvoke, IInitializable
    //    {
    //        #region IInitializable

    //        /// <summary>
    //        /// Complete initialization for the component</summary>
    //        public void Initialize() {
    //            m_uiDispatcher = Dispatcher.CurrentDispatcher;
    //        }

    //        #endregion

    //        #region ISynchronizeInvoke

    //        /// <summary>
    //        /// Asynchronously executes the delegate on the thread that created this object.</summary>
    //        /// <param name="method">A Delegate to a method that takes parameters of the same number and
    //        /// type that are contained in args. </param>
    //        /// <param name="args">An array of type Object to pass as arguments to the given method. This 
    //        /// can be null if no arguments are needed. </param>
    //        /// <returns>An IAsyncResult interface that represents the asynchronous operation started by calling this method.</returns>
    //        public IAsyncResult BeginInvoke(Delegate method, object[] args) {
    //            if (args != null && args.Length > 1) {
    //                object[] argsSansFirst = GetArgsAfterFirst(args);
    //                DispatcherOperation op = m_uiDispatcher.BeginInvoke(DispatcherPriority.Normal, method, args[0], argsSansFirst);
    //                return new DispatcherAsyncResultAdapter(op);
    //            }
    //            else {
    //                if (args != null) {
    //                    return new DispatcherAsyncResultAdapter(m_uiDispatcher.BeginInvoke(DispatcherPriority.Normal, method, args[0]));
    //                }
    //                else {
    //                    return new DispatcherAsyncResultAdapter(m_uiDispatcher.BeginInvoke(DispatcherPriority.Normal, method));
    //                }
    //            }
    //        }

    //        /// <summary>
    //        /// Waits until the process started by calling BeginInvoke completes, and then returns the 
    //        /// value generated by the process.</summary>
    //        /// <param name="result">An IAsyncResult interface that represents the asynchronous operation 
    //        /// started by calling BeginInvoke. </param>
    //        /// <returns>An Object that represents the return value generated by the asynchronous operation.</returns>
    //        public object EndInvoke(IAsyncResult result) {
    //            DispatcherAsyncResultAdapter res = result as DispatcherAsyncResultAdapter;
    //            if (res == null)
    //                throw new InvalidCastException();


    //            while (res.Operation.Status != DispatcherOperationStatus.Completed || res.Operation.Status == DispatcherOperationStatus.Aborted) {
    //                Thread.Sleep(50);
    //            }

    //            return res.Operation.Result;
    //        }

    //        /// <summary>
    //        /// Synchronously executes the delegate on the thread that created this object and 
    //        /// marshals the call to the creating thread.</summary>
    //        /// <param name="method">A Delegate that contains a method to call, in the context of 
    //        /// the thread for the control. </param>
    //        /// <param name="args">An array of type Object that represents the arguments to pass to 
    //        /// the given method. This can be null if no arguments are needed. </param>
    //        /// <returns>An Object that represents the return value from the delegate being invoked, 
    //        /// or null if the delegate has no return value.</returns>
    //        public object Invoke(Delegate method, object[] args) {
    //            if (args != null && args.Length > 1) {
    //                object[] argsSansFirst = GetArgsAfterFirst(args);
    //                return m_uiDispatcher.Invoke(DispatcherPriority.Normal, method, args[0], argsSansFirst);
    //            }
    //            else {
    //                if (args != null) {
    //                    return m_uiDispatcher.Invoke(DispatcherPriority.Normal, method, args[0]);
    //                }
    //                else {
    //                    return m_uiDispatcher.Invoke(DispatcherPriority.Normal, method);
    //                }

    //            }
    //        }

    //        /// <summary>
    //        /// Gets a value indicating whether the caller must call Invoke when calling 
    //        /// an object that implements this interface.</summary>
    //        public bool InvokeRequired {
    //            get { return m_uiDispatcher.Thread != Thread.CurrentThread; }
    //        }

    //        #endregion

    //        private static object[] GetArgsAfterFirst(object[] args) {
    //            object[] result = new object[args.Length - 1];
    //            Array.Copy(args, 1, result, 0, args.Length - 1);
    //            return result;
    //        }

    //        private class DispatcherAsyncResultAdapter : IAsyncResult
    //        {
    //            public DispatcherAsyncResultAdapter(DispatcherOperation operation) {
    //                m_op = operation;
    //            }

    //            public DispatcherAsyncResultAdapter(DispatcherOperation operation, object state)
    //                : this(operation) {
    //                m_state = state;
    //            }

    //            public DispatcherOperation Operation {
    //                get { return m_op; }
    //            }

    //            #region IAsyncResult Members

    //            public object AsyncState {
    //                get { return m_state; }
    //            }

    //            public WaitHandle AsyncWaitHandle {
    //                get { return null; }
    //            }

    //            public bool CompletedSynchronously {
    //                get { return false; }
    //            }

    //            public bool IsCompleted {
    //                get { return m_op.Status == DispatcherOperationStatus.Completed; }
    //            }

    //            #endregion

    //            private DispatcherOperation m_op;
    //            private object m_state;
    //        }

    //        private Dispatcher m_uiDispatcher;
    //    }

    internal class WipingThread : BackgroundWorker
    {
        /// <summary>
        /// 暂停
        /// </summary>
        public event EventHandler<EventArgs> WorkerSuspended;
        /// <summary>
        /// 继续
        /// </summary>
        public event EventHandler<EventArgs> WorkerContinued;

        private readonly GuiInvokeHelper invoker;
        private Thread thread;

        public WipingThread()
            : base() {
            this.invoker = new GuiInvokeHelper();
            this.thread = null;
        }

        private volatile Boolean paused = false;
        public Boolean Paused {
            get {
                return this.paused;
            }
            set {
                if (this.paused != value) {
                    this.paused = value;
                }
            }
        }

        private volatile Object argument = null;
        public Object Argument {
            get {
                return this.argument;
            }
            set {
                if (this.argument != value) {
                    this.argument = value;
                }
            }
        }

        public virtual void ReportSuspended() {
            if (this.WorkerSuspended != null) {
                if (this.invoker.InvokeRequired) {
                    this.invoker.Invoke(this.WorkerSuspended, new Object[] { this, EventArgs.Empty });
                }
                else {
                    this.WorkerSuspended(this, EventArgs.Empty);
                }
            }
        }

        public virtual void ReportContinued() {
            if (this.WorkerContinued != null) {
                if (this.invoker.InvokeRequired) {
                    this.invoker.Invoke(this.WorkerContinued, new Object[] { this, EventArgs.Empty });
                }
                else {
                    this.WorkerContinued(this, EventArgs.Empty);
                }
            }
        }

        public void Kill() {
            if (this.thread != null) {
                this.thread.Abort();
                this.thread = null;
            }
        }

        protected override void OnDoWork(DoWorkEventArgs args) {
            try {
                // A background worker thread comes from the thread pool and such 
                // a thread cannot have the STA apartment state. Therefore, do not 
                // change this thread's apartment state! 
                // See also: http://social.msdn.microsoft.com/forums/en-US/Vsexpressvb/thread/a23a47f8-efd2-4117-b107-6757254d8e27
                this.thread = Thread.CurrentThread;

                // Called by RunWorkerAsync().
                // Therefore, run means run!
                this.Paused = false;
                this.Argument = args.Argument;

                base.OnDoWork(args);
            }
            catch (ThreadAbortException) {
                args.Cancel = true; // Cancel property has to be set!
                Thread.ResetAbort(); // Prevent exception propagation.
            }
        }

        private class GuiInvokeHelper : ISynchronizeInvoke
        {
            // For more details about this solution see:
            // http://stackoverflow.com/questions/6708765/how-to-invoke-when-i-have-no-control-available

            private readonly SynchronizationContext context;
            private readonly Thread thread;
            private readonly Object locker;

            public GuiInvokeHelper()
                : base() {
                this.context = SynchronizationContext.Current;
                this.thread = Thread.CurrentThread;
                this.locker = new Object();
            }

            #region ISynchronizeInvoke member implementation section.

            public Boolean InvokeRequired {
                get {
                    return Thread.CurrentThread.ManagedThreadId != this.thread.ManagedThreadId;
                }
            }

            [Obsolete("This method is not supported!", true)]
            public IAsyncResult BeginInvoke(Delegate method, Object[] args) {
                throw new NotSupportedException();
            }

            [Obsolete("This method is not supported!", true)]
            public Object EndInvoke(IAsyncResult result) {
                throw new NotSupportedException();
            }

            public Object Invoke(Delegate method, Object[] args) {
                if (method == null) {
                    throw new ArgumentNullException("method");
                }

                lock (this.locker) {
                    Object result = null;

                    SendOrPostCallback invoker = new SendOrPostCallback(
                        delegate (Object data) {
                            result = method.DynamicInvoke(args);
                        });

                    this.context.Send(new SendOrPostCallback(invoker), method.Target);

                    return result;
                }
            }

            public Object Invoke(Delegate method) {
                return this.Invoke(method, null);
            }

            #endregion // ISynchronizeInvoke member implementation section.
        }
    }
}

namespace RSG.Unity3D {
    using System.Threading;
    using System.ComponentModel;
    using System.Collections.Generic;
    using System;
#if UNITY_EDITOR
    using UnityEditor;
#endif
    public class DeferredSynchronizeInvoke : ISynchronizeInvoke
    {
#if UNITY_EDITOR
        [InitializeOnLoadMethod]
        private static void Init() {
            mainThread = Thread.CurrentThread;
            EditorApplication.update += ProcessQueue;
        }
#else

#endif
        private Queue<AsyncResult> toExecute = new Queue<AsyncResult>();
        private Thread mainThread;
        public bool InvokeRequired { get { return mainThread.ManagedThreadId != Thread.CurrentThread.ManagedThreadId; } }

        public DeferredSynchronizeInvoke() {
            mainThread = Thread.CurrentThread;
        }
        public IAsyncResult BeginInvoke(Delegate method, object[] args) {
            var asyncResult = new AsyncResult() {
                method = method,
                args = args,
                IsCompleted = false,
                manualResetEvent = new ManualResetEvent(false),
                invokingThread = Thread.CurrentThread
            };

            if (InvokeRequired) {//(mainThread.ManagedThreadId != asyncResult.invokingThread.ManagedThreadId){
                lock (toExecute)
                    toExecute.Enqueue(asyncResult);
            }
            else {
                asyncResult.Invoke();
                asyncResult.CompletedSynchronously = true;
            }

            return asyncResult;
        }
        public object EndInvoke(IAsyncResult result) {
            if (!result.IsCompleted)
                result.AsyncWaitHandle.WaitOne();

            return result.AsyncState;
        }
        public object Invoke(Delegate method, object[] args) {
            if (InvokeRequired) {
                var asyncResult = BeginInvoke(method, args);
                return EndInvoke(asyncResult);
            }
            else {
                return method.DynamicInvoke(args);
            }
        }
        public void ProcessQueue() {
            if (Thread.CurrentThread != mainThread)
                throw new Exception(
                    "must be called from the same thread it was created on " +
                    "(created on thread id: " + mainThread.ManagedThreadId + ", called from thread id: " + Thread.CurrentThread.ManagedThreadId
                );

            AsyncResult data = null;
            while (true) {
                lock (toExecute) {
                    if (toExecute.Count == 0)
                        break;
                    data = toExecute.Dequeue();
                }

                data.Invoke();
            }
        }

        private class AsyncResult : IAsyncResult
        {
            public Delegate method;
            public object[] args;
            public bool IsCompleted { get; set; }
            public WaitHandle AsyncWaitHandle { get { return manualResetEvent; } }
            public ManualResetEvent manualResetEvent;
            public Thread invokingThread;
            public object AsyncState { get; set; }
            public bool CompletedSynchronously { get; set; }

            public void Invoke() {
                AsyncState = method.DynamicInvoke(args);
                IsCompleted = true;
                manualResetEvent.Set();
            }
        }

        //public class UnitySynchronizeInvokeExample : MonoBehaviour
        //{
        //    private DeferredSynchronizeInvoke synchronizeInvoke;

        //    private void Start() {
        //        synchronizeInvoke = new DeferredSynchronizeInvoke();
        //        new Thread(ThreadMain).Start();
        //    }
        //    private void ThreadMain() {
        //        while (true) {
        //            var retObj = synchronizeInvoke.Invoke((System.Func<string>)(() =>
        //            {
        //                this.transform.localScale = Vector3.one * Random.Range(1.0f, 10.0f);
        //                return this.gameObject.name;
        //            }), null);
        //            Debug.Log("Waited for the end of synchronizeInvoke and it synchronously returned me: " + (retObj as string));
        //            Thread.Sleep(1 * 1000);
        //        }
        //    }
        //    private void Update() {
        //        synchronizeInvoke.ProcessQueue();
        //    }
        //}
    }
}